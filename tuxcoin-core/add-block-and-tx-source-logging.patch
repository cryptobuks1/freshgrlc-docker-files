diff -uNr tuxcoin-V2-2.0.orig/src/net_processing.cpp tuxcoin-V2-2.0/src/net_processing.cpp
--- tuxcoin-V2-2.0.orig/src/net_processing.cpp	2019-01-05 01:35:29.000000000 +0100
+++ tuxcoin-V2-2.0/src/net_processing.cpp	2019-05-21 01:22:53.137463057 +0200
@@ -1409,6 +1409,10 @@
         // If this set of headers is valid and ends in a block with at least as
         // much work as our tip, download as much as possible.
         if (fCanDirectFetch && pindexLast->IsValid(BLOCK_VALID_TREE) && chainActive.Tip()->nChainWork <= pindexLast->nChainWork) {
+            if (chainActive.Tip()->phashBlock && *chainActive.Tip()->phashBlock != headers[nCount-1].GetHash()) {
+                LogPrintf("New block %s from %s\n", headers[nCount-1].GetHash().ToString(), pfrom->addr.ToString());
+            }
+
             std::vector<const CBlockIndex*> vToFetch;
             const CBlockIndex *pindexWalk = pindexLast;
             // Calculate all the blocks we'd need to switch to pindexLast, up to a limit.
@@ -1881,6 +1885,10 @@
             bool fAlreadyHave = AlreadyHave(inv);
             LogPrint(BCLog::NET, "got inv: %s  %s peer=%d\n", inv.ToString(), fAlreadyHave ? "have" : "new", pfrom->GetId());
 
+            if (!fAlreadyHave && (inv.type == MSG_TX || inv.type == MSG_BLOCK)) {
+                LogPrintf("New %s %s from %s\n", inv.type == MSG_TX ? "tx" : "block", inv.hash.ToString(), pfrom->addr.ToString());
+            }
+
             if (inv.type == MSG_TX) {
                 inv.type |= nFetchFlags;
             }
@@ -2333,6 +2341,10 @@
             }
         }
 
+        if (pindex) {
+            LogPrintf("New block %s from %s\n", pindex->GetBlockHash().ToString(), pfrom->addr.ToString());
+        }
+
         // When we succeed in decoding a block's txids from a cmpctblock
         // message we typically jump to the BLOCKTXN handling code, with a
         // dummy (empty) BLOCKTXN message, to re-use the logic there in
